###1.解释”static”关键字？
  
（1）static修饰的变量称作静态变量，被所有对象所共享，在内存中只有一份(区别于类的实例变量，实例变量是每个实例都有一份)，它仅在类初次加载时才被初始化，可以当作全局变量来用。  
static int i = 1;  

（2）static修饰的方法（函数）称作静态方法，它不依赖于任何对象就可被访问，它不依附于任何对象，因此没有this。  

并且由于这个特性，static方法中不能访问非static变量和非static方法，因为它们必须依赖具体对象才能被调用，而static方法使用时，这些具体对象可能还未创建。  

（3）static还有关键作用就是构造静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次加载时，会按static块顺序来执行每个static块，并且只会执行一次。  

（4）static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定，而static方法是编译时静态绑定的。

  
  
###2.抽象类（使用abstract修饰的类）和接口（interface）的区别：  
  （1）抽象类可拥有任意的成员数据，也可拥有非抽象方法；但接口仅能有静态、不能修改的成员数据，同时所有方法必须是抽象的。      
  （2）在某种程度说，接口是抽象类的特殊化。  
  （3）子类只能继承一个抽象类，但可以实现多个接口。  
  （4）抽象类是对类抽象，而接口是对行为抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。  
  （5）对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。  
  （6）默认情况下，建议使用接口而不是抽象类

###3.java的四种引用方式：强引用，软引用，弱引用，虚引用  
* （1）强引用：引用关系最强，永远不会被垃圾回收，JVM宁愿抛出内存溢出错误也不回收（比如使用new来创建的对象）  
* （2）软引用：引用关系次强，只有内存空间不足时，垃圾回收器才会回收  
* （3）弱引用：内存回收时立即回收这类对象 （性能优化策略：建议将线程内创建的map型缓存类数据设为弱引用）  
* （4）虚引用：引用关系最弱，相当于在虚引用上加了一个通知机制，告诉程序该对象将要被回收

###4."=="和equals方法有什么区别？   
* （1）==操作符比较两个变量的值是否相等，即比较变量对应内存中存储数值是否相同。要比较两个基本类型(int、long..)的数据是否相等，只能用==。    
如果一个变量是对象的引用，这就涉及两块内存，对象本身占用一块（堆内存），变量也占用一块内存（栈内存）。例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时变量obj对应内存中存储的数值就是对象占用内存的首地址。对于这种变量，如果要比较两个变量是否指向同一个对象，就需要用==操作符比较。  
* （2）equals方法用于比较两个对象的内容是否相同。例如：  
String a=new String("foo");  
String b=new String("foo");  
这里创建两个对象，用a,b这两个变量分别指向一个对象，这是两个不同的对象（两个new，分配的内存肯定不同），内存首地址不同，即a和b中存储的数值不同，所以a==b将返回false，而这两个对象中的内容是相同的，所以a.equals(b)将返回true。  
字符串的比较基本上都是使用equals方法。  
* 如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，实现代码如下：  
  `boolean equals(Object o){  
  return this==o;  
  }`  
  这说明如果一个类没有定义equals方法，默认equals方法就是用==操作符，这时用equals和==会得到同样结果，如果比较两个不同对象则总返回false。如果你的类希望能比较该类创建的两个实例对象的内容是否相同，那么必须覆盖（自定义）equals方法。
  
 ###5.Overload和Override的区别
 * Overload是重载，Override是覆盖，也就是重写。  
 * 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。  
 * 重写Override表示子类方法可与父类的方法名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这是面向对象（封装、继承、多态）多态的一种表现。  
 * 子类覆盖父类方法时，只能比父类抛出更少异常，或抛出父类异常的子异常，因为子类可解决父类的一些问题，不能比父类有更多的问题。  
 * 子类方法的访问权限只能比父类的更大。如果父类方法是private类型，则等于子类增加一个新方法（子类不可见父类的private类型 public protected private）。（异常更少，访问权限更大）
 
 ###6.HashMap的数据结构是什么？如何实现的？和HashTable、ConcurrentHashMap的区别？
   
   * 在Java 8中，HashMap的数据结构是由Node<k,v>作为元素组成的数组：（1）如果多个值hash到同一桶中则组成一个链表，当这个链表的节点个数超过一定值时，将这个链表重构为一个二叉树；（2）如果发现map中的元素个数超过了阈值，则进行空间扩容——空间倍增。
   * HashMap和HashTable数据结构和操作基本相同，区别是前者是非线程安全，并且HashMap接受value为null。
   * ConcurrentHashMap和HashTable都是线程安全的，区别是：HashTable每次操作都会锁住整个表结构，导致一次只能有一个线程访问HashTable对象，而ConcurrentHashMap不会，只会锁住某个节点，只有在涉及到size操作时才会锁整个表结构。
   
 
7、解释内存中栈(stack)、堆(heap)和方法区(method area)的用法。 
答：通常我们定义基本数据类型(int i=1)，对象引用(Integer i =2)，还有函数调用的现场(出入参数、返回值等)都使用栈空间；  
通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；  
程序中的字面量和常量都是放在常量池中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。

String str = new String("hello");
1
上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区的。

补充1：较新版本的Java（从Java 6的某个更新开始）中，由于JIT编译器的发展和"逃逸分析"技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。

补充2：运行时常量池相当于Class文件常量池具有动态性，Java语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String类的intern()方法就是这样的。

看看下面代码的执行结果是什么并且比较一下Java 7以前和以后的运行结果是否一致。

String s1 = new StringBuilder("go")
    .append("od").toString();
System.out.println(s1.intern() == s1);
String s2 = new StringBuilder("ja")
    .append("va").toString();
System.out.println(s2.intern() == s2);
  
  
8.为什么要装箱（int -- Integer）    
* （1）把基本类型包装成类，可以使这个类型具有很多方法和状态，比如方法返回Boolean，对处理失败可以直接返回null，而不应该是默认的初始值false（对基本类型来说）  
* （2）Java向面向对象语言的靠近。其实Java还不算纯正的面向对象语言。真正的面向对象，没有基本数据类型，只有对象。  
* （3）在泛型中基本类型是不可做泛型参数的。如：List <int> list = new ArrayList<int> ();这是不合法的。只能这样写List<Integer> list = new ArrayList<Integer> ();也就是要用int型的包装类类型来解决基本类型不可以做泛型参数的问题 。

9.String和StringBuilder、StringBuffer的区别？ 
*   String和StringBuffer/StringBuilder，它们都可以储存和操作字符串。  
*   String是只读字符串，创建之后不能更改（每次String的变化都是新创建了一个String，并把新String指向原来的变量）。  
*   StringBuffer：字符串变量（线程安全），可直接修改
*  StringBuilder字符串变量（线程不安全）可直接修改。StringBuilder在单线程下使用，效率比StringBuffer高。  
*   字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象
  
10.String s = new String("xyz");创建了几个字符串对象？ 
   答：两个对象，一个是常量区的"xyz"，一个是用new创建在堆上的对象。

11。Java 中的final关键字有哪些用法？ 
*    (1)修饰类：表示该类不能被继承；  
*    (2)修饰方法：表示方法不能被重写；  
*    (3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。
   
12.什么时候用断言（assert）？ 
 *    断言是常用的调试方式，很多开发语言都支持。一般用于保证程序最基本、关键的正确性。断言通常在开发和测试时开启，为保证程序效率，软件发布后通常关闭。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。断言使用如下：
    
    assert(a > 0); // throws an AssertionError if a <= 0
    断言可以有两种形式： 
    assert Expression1; 
    assert Expression1 : Expression2 ; 
    Expression1 应该总是产生一个布尔值。 
    Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。
    
    要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。
    
13.Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally如何使用？ 
 * Java把各种不同的异常进行分类，并提供良好的接口。
 * 在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。
 * Java异常处理通过5个关键词实现：try、catch、throw、throws和finally。
 * 一般用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；
 * try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；
 * throw语句用来明确地抛出一个异常；throws用来声明一个方法可能抛出的各种异常；
 * finally确保范围内的代码无论如何（及时抛了异常）都要被执行；
 * try语句可以嵌套。
 
 14.（容器）List、Map、Set三个接口存取元素时，各有什么特点？ 
 * List以特定索引来存取元素，可以有重复元素 List<String>。
 * Set不能存放重复元素（可用对象的equals()方法区分元素是否重复） Set<String>。
 * Map保存键值对（KV）映射，映射关系可以是一对一或多对一。
 * Set和Map都有基于哈希和树的两种实现版本，基于哈希的理论插入／读取时间复杂度都为O(1)，而基于排序树版本在插入／删除元素时会按照元素的键（key）构成排序树从而达到排序和去重的效果（HashMap--TreeMap）(HashSet--TreeSet)。
 
 15.(线程)Thread类的sleep()方法、yield()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? 
 * sleep()方法（休眠）会让当前线程暂停执行指定时间{sleep(10)}，将执行机会（CPU）让给其他线程（线程自身进入阻塞状态），休眠时间结束后会自动恢复进入就绪状态(对象的锁依然保持)。
 * wait()是Object类的方法，会导致当前线程放弃对象的锁（线程暂停执行），只有调用对象的notify()（或notifyAll()方法）时才能唤醒线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。
 * sleep()给其他线程运行机会时不考虑线程优先级，会给低优先级的线程以运行机会；yield()方法只给相同或更高优先级线程以运行机会； 
 * 线程执行sleep()方法后转入阻塞状态，而执行yield()方法后转入就绪状态；
 
 16.解释同步和异步
 * 同步：发送方在发送请求时，若该请求需要一段时间才能返回结果，该进程将一直等待，直到有返回信息才继续执行；
 * 异步：发送方不需要一直等，而是继续执行其他操作，当有结果返回时系统会通知进程进行处理，这样可以提高执行效率
 
 17.简要说明java中的线程池
 * 创建和销毁线程是需要消耗系统资源的，因为创建线程要获取内存或其它更多资源。提高效率的一个手段就是尽可能减少创建和销毁线程的次数，这就是”池化资源”技术。
 * 线程池就是事先创建若干个可执行线程放入一个池（容器）中，需要时从池中获取线程而不是自行创建，使用完毕不需销毁线程而是放回池中，从而减少创建和销毁线程的开销。 
 * Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。工具类Executors面提供了一些静态工厂方法，生成一些常用线程池，如下所示： 
 * - newSingleThreadExecutor：创建单线程的线程池。池中只有一个线程工作，就相当于单线程串行执行所有任务。此线程池保证所有任务按序执行。 
 * - newFixedThreadPool：创建固定大小的线程池。每提交一个任务就创建一个线程，直到线程达到线程池的最大大小。一旦达到最大值就保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 
 * - newCachedThreadPool：创建一个可缓存线程池。如果线程池大小超过所需的线程数，就会回收部分空闲线程，当任务数增加时，此线程池又可以智能添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 
 * - newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 
 
 18.用Java写一个单例类
单例：该对象的实例只创建一次，可避免对象重复创建，优化程序性能。
 >public class Singleton {  
      private Singleton(){}  
      private static Singleton instance = new Singleton();  
      public static Singleton getInstance(){  
      return instance;
      }
   }

 19.Exception和Error的区别
 * Error一般指系统的问题，如系统崩溃，虚拟机错误，内存不足，方法调用栈溢出等。对这类错误导致的程序中断，仅靠程序本身无法恢复和预防，建议让程序终止。
 * Exception表示程序可处理的异常，可捕获且可能恢复。这类异常应该尽可能处理，使程序恢复运行，不应该随意终止异常。
 * Exception又分运行时异常（RuntimeException）和受检异常(CheckedException )。运行时异常（NullPointerException等），编译能通过，但一运行就终止，出现这类异常时程序会终止。而受检异常（强制必须处理，否则编译不通过）要么用try--catch捕获，要么用throws抛出给父类处理，否则编译不通过。
    
20.范型是什么？有什么作用？
 * 泛型本质是参数化类型，就是说所操作的数据类型被指定为一个参数，泛型在编译时候检查类型安全，并且所有的强制转换都是自动和隐式的，可以提高代码重用率（安全、简单、便于复用）。  
 --
 List\<E>即为范型接口  
 List<String> str = new ArrayList<>();  
 List<String> str2 = new LinkedList<>();
 
21.距离说明程序设计中的几种锁
* 悲观锁和乐观锁---悲观锁(Pessimistic Lock), 很悲观，每次拿数据都认为别人会修改，所以都会上锁，这样别人想拿这个数据就会block直到拿到锁。传统关系型数据库里用到很多这种锁，比如行锁，表锁等，读锁，写锁等，都是在操作前先上锁。--乐观锁(Optimistic Lock), 很乐观，每次拿数据时都认为别人不会修改，所以不上锁，但在更新时会判断在此期间别人有没有去更新这个数据，可使用版本号等机制。乐观锁适用读多写少的场景，可以提高吞吐量。--两种锁各有优缺点，不可认为一种好于另一种，乐观锁适用于写比较少的情况，即冲突真的很少发生时，这样可以省去锁开销，加大系统吞吐量。但如果经常有冲突（并发量大），上层应用会不断重试（判断经常不通过），这样反倒降低了性能，所以用悲观锁就比较合适。

* 读写锁：允许多个读操作同时进行，但每次只允许一个写操作。读写锁是一种性能优化策略。读数据时使用读锁，写数据时使用写锁，如果没有写锁时，读是无阻塞的,能提高程序执行效率。

* 自旋锁：自旋锁使线程在没有取得锁时不挂起，而去执行空循环（自旋），若干个空循环后如果可以获得锁则继续执行。若依然不能获得锁才被挂起。使用自旋锁后线程被挂起几率相对减少，线程执行连贯性得到加强。对于锁竞争激烈、锁占用时间很短的并发线程，具有积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后还是无法获得锁，不仅仅浪费CPU时间，最终还被挂起，反而浪费了系统资源。

                                                                                                                                                
                                                                                                                                                
                                                                                                                                                
                                                                                        
    



