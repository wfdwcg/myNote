###1.解释”static”关键字？
  
（1）static修饰的变量称作静态变量，被所有对象所共享，在内存中只有一份，它仅在类初次加载时才被初始化，可以当作全局变量来用。  
static int i = 1;  

（2）static修饰的方法（函数）称作静态方法，它不依赖于任何对象就可被访问，它不依附于任何对象，因此没有this。  

并且由于这个特性，static方法中不能访问非static变量和非static方法，因为它们必须依赖具体对象才能被调用，而static方法使用时，这些具体对象可能还未创建。  

（3）static还有关键作用就是构造静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次加载时，会按static块顺序来执行每个static块，并且只会执行一次。  

（4）static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定，而static方法是编译时静态绑定的。

  
  
###2.抽象类（使用abstract修饰的类）和接口（interface）的区别：  
  （1）抽象类可拥有任意的成员数据，也可拥有非抽象方法；但接口仅能有静态、不能修改的成员数据，同时所有方法必须是抽象的。      
  （2）在某种程度说，接口是抽象类的特殊化。  
  （3）子类只能继承一个抽象类，但可以实现多个接口。  
  （4）抽象类是对类抽象，而接口是对行为抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。  
  （5）对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。  
  （6）默认情况下，建议使用接口而不是抽象类

###3.java的四种引用方式：强引用，软引用，弱引用，虚引用  
* （1）强引用：引用关系最强，永远不会被垃圾回收，JVM宁愿抛出内存溢出错误也不回收（比如使用new来创建的对象）  
* （2）软引用：引用关系次强，只有内存空间不足时，垃圾回收器才会回收  
* （3）弱引用：内存回收时立即回收这类对象 （性能优化策略：建议将线程内创建的map型缓存类数据设为弱引用）  
* （4）虚引用：引用关系最弱，相当于在虚引用上加了一个通知机制，告诉程序该对象将要被回收

###4."=="和equals方法有什么区别？   
* （1）==操作符比较两个变量的值是否相等，即比较变量对应内存中存储数值是否相同。要比较两个基本类型(int、long..)的数据是否相等，只能用==。    
如果一个变量是对象的引用，这就涉及两块内存，对象本身占用一块（堆内存），变量也占用一块内存（栈内存）。例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时变量obj对应内存中存储的数值就是对象占用内存的首地址。对于这种变量，如果要比较两个变量是否指向同一个对象，就需要用==操作符比较。  
* （2）equals方法用于比较两个对象的内容是否相同。例如：  
String a=new String("foo");  
String b=new String("foo");  
这里创建两个对象，用a,b这两个变量分别指向一个对象，这是两个不同的对象（两个new，分配的内存肯定不同），内存首地址不同，即a和b中存储的数值不同，所以a==b将返回false，而这两个对象中的内容是相同的，所以a.equals(b)将返回true。  
字符串的比较基本上都是使用equals方法。  
* 如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，实现代码如下：  
  `boolean equals(Object o){  
  return this==o;  
  }`  
  这说明如果一个类没有定义equals方法，默认equals方法就是用==操作符，这时用equals和==会得到同样结果，如果比较两个不同对象则总返回false。如果你的类希望能比较该类创建的两个实例对象的内容是否相同，那么必须覆盖（自定义）equals方法。
  
 ###5.Overload和Override的区别
 * Overload是重载，Override是覆盖，也就是重写。  
 * 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。  
 * 重写Override表示子类方法可与父类的方法名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这是面向对象（封装、继承、多态）多态的一种表现。  
 * 子类覆盖父类方法时，只能比父类抛出更少异常，或抛出父类异常的子异常，因为子类可解决父类的一些问题，不能比父类有更多的问题。  
 * 子类方法的访问权限只能比父类的更大。如果父类方法是private类型，则等于子类增加一个新方法（子类不可见父类的private类型 public protected private）。（异常更少，访问权限更大）
 
 ###6.HashMap的数据结构是什么？如何实现的？和HashTable、ConcurrentHashMap的区别？
   
   * 在Java 8中，HashMap的数据结构是由Node<k,v>作为元素组成的数组：（1）如果多个值hash到同一桶中则组成一个链表，当这个链表的节点个数超过一定值时，将这个链表重构为一个二叉树；（2）如果发现map中的元素个数超过了阈值，则进行空间扩容——空间倍增。
   * HashMap和HashTable数据结构和操作基本相同，区别是前者是非线程安全，并且HashMap接受value为null。
   * ConcurrentHashMap和HashTable都是线程安全的，区别是：HashTable每次操作都会锁住整个表结构，导致一次只能有一个线程访问HashTable对象，而ConcurrentHashMap不会，只会锁住某个节点，只有在涉及到size操作时才会锁整个表结构。
