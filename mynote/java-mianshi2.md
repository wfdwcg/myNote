1.距离说明程序设计中的几种锁
* 悲观锁和乐观锁---悲观锁(Pessimistic Lock), 很悲观，每次拿数据都认为别人会修改，所以都会上锁，这样别人想拿这个数据就会block直到拿到锁。传统关系型数据库里用到很多这种锁，比如行锁，表锁等，读锁，写锁等，都是在操作前先上锁。--乐观锁(Optimistic Lock), 很乐观，每次拿数据时都认为别人不会修改，所以不上锁，但在更新时会判断在此期间别人有没有去更新这个数据，可使用版本号等机制。乐观锁适用读多写少的场景，可以提高吞吐量。--两种锁各有优缺点，不可认为一种好于另一种，乐观锁适用于写比较少的情况，即冲突真的很少发生时，这样可以省去锁开销，加大系统吞吐量。但如果经常有冲突（并发量大），上层应用会不断重试（判断经常不通过），这样反倒降低了性能，所以用悲观锁就比较合适（高并发下修改数据库的同一行数据）。

* 读写锁：允许多个读操作同时进行，但每次只允许一个写操作。读写锁是一种性能优化策略。读数据时使用读锁，写数据时使用写锁，如果没有写锁时，读是无阻塞的,能提高程序执行效率。

* 自旋锁：自旋锁使线程在没有取得锁时不挂起，而去执行空循环（自旋），若干个空循环后如果可以获得锁则继续执行。若依然不能获得锁才被挂起。使用自旋锁后线程被挂起几率相对减少，线程执行连贯性得到加强。对于锁竞争激烈、锁占用时间很短的并发线程，具有积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后还是无法获得锁，不仅仅浪费CPU时间，最终还被挂起，反而浪费了系统资源。

2.解释一下RPC
* RPC（Remote Procedure Call Protocol）就是远程调用，本质上是一种通信方式。核心思想是将不同进程间的通讯抽象为函数调用，基本过程是调用端通过将参数序列化到流中并发送给服务端，服务端从流中反序列化出参数并完成实际处理，然后将结果序列化后返回给调用端。通常RPC通过接口来实现，接口定义服务名，接口方法定义每个请求的入参和结果。RPC内部的序列化、网络通讯等细节则由框架完成，对用户完全透明。

3.索引在数据库中有什么作用？
* 加快数据查询（以空间换时间）
*  数据库中查询最频繁。索引是对数据库表中一个或多个列的值进行排序的结构。与搜索所有行相比，索引用指针指向存储（在表中指定列）的数据，然后根据指定次序排列这些指针，有助于更快获取信息。通常经常查询索引列时才需要在表上创建索引。索引将占用磁盘空间，影响数据更新速度。但多数情况下索引带来的速度优势大大超过不足。
*  主键、二级索引、覆盖索引
*  三种层次的索引：（1）通过索引

4.面向对象的特征有哪些方面？ 
* 抽象：将一类对象的共同特征总结出来构造成类，包括数据抽象和行为抽象。抽象只关注对象有哪些属性和行为，不关注行为细节。 
* 继承：从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让程序有一定的延续性。
* 封装：封装是把数据和操作数据的方法绑定起来，对数据访问只通过已有接口。面向对象的本质就是将现实世界描绘成一系列对象。在类中编写方法就是对实现细节的封装；编写一个类就是对数据和数据操作的封装。封装就是隐藏一切可隐藏的，只向外界提供最简单的接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好操作更简单；智能手机也是封装得足够好，因为几个按键（接口）就搞定所有事情）。 
* 多态性：多态性是指允许不同子类型的对象对同一消息作出不同响应。简单说是用同样对象引用调用同样方法但是做了不同事情。多态性分为编译时多态性和运行时多态性。方法重载（overload）实现了编译时多态性（也称为前绑定），而方法重写（override）实现了运行时多态性（也称为后绑定）。运行时多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样方法就会根据子类对象的不同而表现出不同行为）。

5.什么是DAO模式？ 
* DAO（Data Access Object）是一个为数据库提供抽象接口的对象，在不暴露底层存储细节的前提下提供各种数据访问操作。
* 实际开发中就是建立一个接口，将所有数据访问操作抽象后封装起来，当需要和数据源交互时使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。
* DAO模式实际包含两部分，一是解决如何访问数据，二是解决如何用对象封装数据。

6.voliatile修饰符有什么作用？
*voliatile变量的变更对任何线程都立即可见，可避免并发修改变量导致的数据不一致（机制：插入内存屏障，确保所有访问者从主存储中读取数据，而不是从线程缓存中读取）*
*禁止指令重排序（JVM为加快程序执行做的优化，在单线程里可提升效率，多线程时可能导致同步问题）*

7.解释Synchronized关键字
* synchronized是Java关键字，是一种同步锁,它用来修饰一个方法或代码块时，保证在同一时刻最多只有一个线程执行该段代码： 
* 修饰方法，在方法声明中加入 synchronized关键字来实现：每个类实例有一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而避免了类成员变量的访问冲突。 
* 修饰代码块：synchronized 方法有缺陷：大方法声明为synchronized会大大影响效率，Java为我们提供了更好的解决办法，那就是 synchronized 块。（实际就是对尽可能少的必要代码加锁）
